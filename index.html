<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="css/simple.css"/>
  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
    <title>Intro to Haskell for Erlangers</title>
    <link rel="stylesheet" href="css/slides.css"/>
    <script src="d3/d3.min.js"></script>
    <script src="js/slides.js"></script>
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="title" class="slide level1">
<h1></h1>
<h1>
    
Intro to Haskell<br> for Erlangers
</h1>
<h3>
    
Bob Ippolito (<a href="https://twitter.com/etrepum"><span class="citation" data-cites="etrepum">@etrepum</span></a>)<br> Erlang Factory SF<br> March 7, 2014
</h3>
<h4>
<a href="http://bob.ippoli.to/haskell-for-erlangers-2014/">bob.ippoli.to/haskell-for-erlangers-2014</a>
</h4>

</section>
<section id="who-am-i" class="slide level1">
<h1>Who am I?</h1>
<ul>
<li>Not classically trained in CS</li>
<li>Erlang user since 2006 (Mochi Media, mochiweb, etc.)</li>
<li>Haskell user since 2012 (ported <a href="http://exercism.io">exercism.io</a> curriculum)</li>
<li>Currently teaching web technologies to teenagers with <a href="http://www.missionbit.com/">Mission Bit</a></li>
<li>Doing a bit of advising/investing in startups</li>
</ul>
</section>
<section id="why-learn-haskell" class="slide level1">
<h1>Why learn Haskell?</h1>
<ul>
<li>I learn a lot of from studying new languages</li>
<li>Types are supposed to help you write better software</li>
<li>I like QuickCheck and Dialyzer</li>
<li>Good support for parallelism and concurrency</li>
<li>Will help me understand more CS papers</li>
</ul>
</section>
<section id="cost-of-concurrency" class="slide level1">
<h1></h1>
<p>RAM footprint per unit of concurrency (approx)</p>
<table id="concurrency-table">
<tr class="haskell">
    <td class="num">
1.3KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>Haskell ThreadId + MVar (GHC 7.6.3, 64-bit)</span>
</td>
</tr>
<tr class="erlang">
    <td class="num">
2.6 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>Erlang process (64-bit)</span>
</td>
</tr>
<tr class="go">
    <td class="num">
4.0 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>Go goroutine</span>
</td>
    <!-- http://tip.golang.org/doc/go1.3#stack_size -->
</tr>
<tr class="c-min">
    <td class="num">
9.0 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>C pthread (minimum, 64-bit Mac OS X)</span>
</td>
    <!-- http://opensource.apple.com/source/Libc/Libc-594.9.5/include/limits.h -->
</tr>
<tr class="java-min">
    <td class="num">
64.0 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>Java thread stack (minimum)</span>
</td>
    <!-- http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#threads_oom -->
</tr>
<tr class="placeholder"><td colspan="2"><hr/></td></td>
<tr class="c">
    <td class="num">
513 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>C pthread (default, 64-bit Mac OS X)</span>
</td>
    <!-- https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7 -->
</tr>
<tr class="java">
    <td class="num">
1024 KB
</td>
    <td class="name">
<div class="bar-ctr">
<div class="bar">

</div>
</div>
<span>Java thread stack (default)</span>
</td>
    <!-- http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#threads_oom -->
</tr>
</table>

</section>
<section id="starting-out" class="slide level1">
<h1>Starting out</h1>
<ul>
<li>Intimidated by Haskell for years</li>
<li>Took a class while at Facebook</li>
<li>Read several books</li>
<li>Deliberate practice</li>
</ul>
</section>
<section id="haskells-appeal" class="slide level1">
<h1>Haskell's Appeal</h1>
<ul>
<li>Abstractions can often be used without penalty</li>
<li>Efficient parallel and concurrent programming</li>
<li>Type system makes maintenance easier</li>
<li>Nice syntax (not too heavy or lightweight)</li>
<li>Fantastic community &amp; ecosystem</li>
</ul>
</section>
<section id="haskell-history" class="slide level1">
<h1>Haskell</h1>
<!-- http://www.haskell.org/haskellwiki/Haskell_Brooks_Curry -->
<figure>
<img src="img/HaskellBCurry.jpg">
<figcaption>
<strong>Haskell</strong> B. Curry
</figcaption>
</figure>

</section>
<section id="early-history" class="slide level1">
<h1>Early History</h1>
<!-- http://www.haskell.org/onlinereport/preface-jfp.html
     http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
-->
<dl>
<dt>1987</dt>
<dd>More than a dozen non-strict FP languages in use
</dd>
<dd>FCPA '87 meeting (Peyton Jones, Hudak, et. al.)
</dd>
<dd>Formed FPLang committee
</dd>
<dd>Wanted to base language on Miranda, but Turner declined
</dd>
<dt>1988</dt>
<dd>Chose the name Haskell
</dd>
<dd>Hudak and Wadler chosen to be editors of the report
</dd>
<dt>1990 (April 1st!)</dt>
<dd>Haskell 1.0 report published (125 pages)
</dd>
</dl>
</section>
<section id="ifip-1992" class="slide level1">
<h1></h1>
<!-- extracted from history.pdf -->
<figure>
<img src="img/ifip-1992.jpg" />
<figcaption>
IFIP 1992 Working Group
</figcaption>
</figure>

</section>
<section id="ifip-1992-erl" class="slide level1">
<h1></h1>
<!-- extracted from history.pdf -->
<figure>
<img src="img/ifip-1992-erl.jpg" />
<figcaption>
John Hughes (QuickCheck), Philip Wadler (Subtyping for Erlang)
</figcaption>
</figure>

</section>
<section id="evolution" class="slide level1">
<h1>Evolution</h1>
<dl>
<dt>1992</dt>
<dd>Glasgow Haskell Compiler (GHC)
</dd>
<dt>1996</dt>
<dd>Haskell 1.3 - Monadic I/O, seq, strictness annotations
</dd>
<dt>1999</dt>
<dd>Haskell 98 - Commitment to stability
</dd>
<dt>2002</dt>
<dd>Revised Haskell 98 (260 pages)
</dd>
<dt>2010</dt>
<dd>Haskell 2010 (300 pages)
</dd>
</dl>
</section>
<section id="domain" class="slide level1">
<h1>Domain</h1>
<p><strong>General Purpose</strong></p>
<ul>
<li>Very effective for parsing and compilation</li>
<li>Great for DSEL (Domain Specific Embedded Languages)</li>
<li>Has been popular in academia for some time</li>
<li>Becoming more popular in industry</li>
</ul>
</section>
<section id="commercial-use" class="slide level1">
<h1>Commercial Use</h1>
<!-- http://www.haskell.org/haskellwiki/Haskell_in_industry -->

<dl>
<dt>Internet</dt>
<dd><a href="https://skillsmatter.com/skillscasts/4429-simon-marlow">Facebook</a> - Haxl rule engine &quot;fighting spam with pure functions&quot;
</dd>
<dt>Biotech</dt>
<dd><a href="http://cufp.galois.com/2008/abstracts.html#BalabanDavid">Amgen</a> - informatics, simulation
</dd>
<dt>Finance</dt>
<dd><a href="http://cufp.galois.com/2006/abstracts.html#HowardMansell">Credit Suisse</a> - quantitative modeling
</dd>
<dd><a href="http://lambda-the-ultimate.org/node/3331">Barclays</a> - DSEL for exotic equity derivatives
</dd>
<dd><a href="http://cufp.galois.com/2008/abstracts.html#PolakowJeff">Deutsche Bank</a> - trading group infrastructure
</dd>
<dd><a href="http://haskell.org/communities/05-2010/html/report.html#sect7.6">Tsuru Capital</a> - trading platform
</dd>
<dd><a href="https://www.youtube.com/watch?v=o3m2NkusI9k">McGraw-Hill Financial</a> - report generation (with <a href="http://ermine-language.github.io/ermine/">ermine</a>)
</dd>
<dt>Semiconductor Design</dt>
<dd><a href="http://www.slideshare.net/mansu/bluespec-talk">Bluespec</a> - high-level language for chip design
</dd>
</dl>
</section>
<section id="consumer-apps" class="slide level1">
<h1>Consumer Apps</h1>
<!--
Bump:
* https://github.com/MichaelXavier/Angel
* http://devblog.bu.mp/post/40786229350/haskell-at-bump
* https://www.fpcomplete.com/wp-content/uploads/2013/05/Bump%20case%20study.pdf

Silk:
* http://engineering.silk.co/post/31920990633/why-we-use-haskell
* https://www.fpcomplete.com/wp-content/uploads/2013/05/Silk%20case%20study.pdf
-->

<dl>
<dt><a href="https://www.silk.co/">Silk</a></dt>
<dd>&quot;A platform for sharing collections about anything&quot;
</dd>
<dt><a href="http://chordify.net/">Chordify</a></dt>
<dd>&quot;Chord transcription for the masses&quot;
</dd>
<dt><a href="https://bu.mp/">Bump</a> (Google, Sep 2013)</dt>
<dd>&quot;Send files, videos, everything!&quot; Mobile + web.
</dd>
<dt><a href="http://www.mailrank.com/">MailRank</a> (Facebook, Nov 2011)</dt>
<dd>Email inbox prioritization. Shuttered post-acquisition.
</dd>
<dt><a href="https://bazqux.com/">Bazqux</a></dt>
<dd>&quot;RSS reader that shows comments to posts&quot;
</dd>
</dl>
</section>
<section id="commercial-services" class="slide level1">
<h1>Commercial Services</h1>
<!--
Janrain:
* https://www.fpcomplete.com/wp-content/uploads/2013/05/janrain%20case%20study.pdf
Scrive:
* https://www.fpcomplete.com/wp-content/uploads/Scrive-case-study.pdf
Spaceport:
* https://github.com/sibblingz/spaceport-sp-opensource
Skedge:
* http://www.youtube.com/watch?v=BveDrw9CwEg
* http://cufp.org/sites/all/files/slides/2013/trinkle.pdf
-->
<dl>
<dt><a href="http://janrain.com/">janrain</a></dt>
<dd>User management platform.
</dd>
<dt><a href="http://spaceport.io/">Spaceport</a> (Facebook, Aug 2013)</dt>
<dd>Mobile game framework using ActionScript 3
</dd>
<dt><a href="http://scrive.com/">scrive</a></dt>
<dd>E-signing service (nordic market)
</dd>
<dt><a href="http://www.openbrain.co.uk/">OpenBrain</a></dt>
<dd>Computing platform for scientific and business analytics
</dd>
<dt><a href="http://skedge.me/">skedge.me</a></dt>
<dd>Enterprise appointment scheduling
</dd>
</dl>
</section>
<section id="compilers" class="slide level1">
<h1>Compilers</h1>
<dl>
<dt>Haskell</dt>
<dd><a href="http://www.haskell.org/ghc/">GHC</a>, <a href="http://ajhc.metasepi.org/">Ajhc</a>, <a href="https://github.com/valderman/haste-compiler">Haste</a>, <a href="https://github.com/ghcjs/ghcjs">GHCJS</a>
</dd>
<dt>Dependently typed</dt>
<dd><a href="http://wiki.portal.chalmers.se/agda/">Agda</a> - also an interactive proof assistant!
</dd>
<dd><a href="http://www.idris-lang.org/">Idris</a> - general purpose
</dd>
<dt>Compile to JavaScript</dt>
<dd><a href="http://elm-lang.org/">Elm</a> - functional reactive in the browser
</dd>
<dd><a href="http://fay-lang.org/">Fay</a> - Haskell subset
</dd>
<dt>Imperative</dt>
<dd><a href="http://pugscode.org/">Pugs</a> - first Perl 6 implementation
</dd>
</dl>
</section>
<section id="standalone-apps" class="slide level1">
<h1>Standalone Apps</h1>
<dl>
<dt><a href="http://johnmacfarlane.net/pandoc/">Pandoc</a></dt>
<dd>Markup swiss-army knife (used to make these slides!)
</dd>
<dt><a href="http://darcs.net/">Darcs</a></dt>
<dd>Distributed revision control system (like Git or Mercurial)
</dd>
<dt><a href="http://xmonad.org/">xmonad</a></dt>
<dd>&quot;the tiling window manager that rocks&quot;
</dd>
<dt><a href="http://gitit.net/">Gitit</a></dt>
<dd>Wiki backed by Git, Darcs, or Mercurial
</dd>
<dt><a href="http://git-annex.branchable.com/">git-annex</a></dt>
<dd>Manage large files with git (similar to Dropbox)
</dd>
<dt><a href="http://www.implicitcad.org/">ImplicitCAD</a></dt>
<dd>Programmatic Solid 3D CAD modeler
</dd>
</dl>
</section>
<section id="haskell-platform" class="slide level1">
<h1>Haskell Platform</h1>
<h3>
Haskell: Batteries Included
</h3>

<ul>
<li><a href="http://www.haskell.org/platform">http://www.haskell.org/platform</a></li>
<li>GHC compiler and GHCi interpreter</li>
<li>Robust and stable set of vetted packages</li>
<li><a href="http://www.haskell.org/cabal/">Cabal</a>; easily fetch more packages from <a href="http://hackage.haskell.org/">Hackage</a></li>
</ul>
</section>
<section id="editor-support" class="slide level1">
<h1>Editor Support</h1>
<dl>
<dt>Emacs</dt>
<dd><a href="http://www.mew.org/~kazu/proj/ghc-mod/en/">ghc-mod</a> + <a href="http://community.haskell.org/~ndm/hlint/">HLint</a>
</dd>
<dt>Vim</dt>
<dd><a href="https://github.com/bitc/hdevtools">hdevtools</a> + <a href="https://github.com/scrooloose/syntastic">Syntastic</a> + <a href="https://github.com/bitc/vim-hdevtools">vim-hdevtools</a>
</dd>
<dt>Sublime Text</dt>
<dd><a href="https://github.com/bitc/hdevtools">hdevtools</a> + <a href="https://github.com/SublimeHaskell/SublimeHaskell">SublimeHaskell</a>
</dd>
<dt>Eclipse</dt>
<dd><a href="http://eclipsefp.github.io/">EclipseFP</a> + <a href="http://community.haskell.org/~ndm/hlint/">HLint</a>
</dd>
<dt>Web</dt>
<dd><a href="https://www.fpcomplete.com/business/haskell-center/overview/">FP Haskell Center</a>
</dd>
</dl>
</section>
<section id="haskell-syntax" class="slide level1">
<h1>Haskell Syntax</h1>
<dl>
<dt>Types</dt>
<dd>Defines types and typeclasses
</dd>
<dd><p>Constructors and record accessors become values</p>
</dd>
<dt>Values</dt>
<dd>Named bindings
</dd>
<dd>Instances of constructors
</dd>
<dd>Functions
</dd>
<dd><p>Control flow</p>
</dd>
</dl>
</section>
<section id="relative-to-erlang" class="slide level1">
<h1>Relative to Erlang</h1>
<ul>
<li>Syntax is minimal &amp; familiar</li>
<li>Haskell's pattern matching is not as clever as Erlang's</li>
<li>Types are kinda like having Dialyzer for every compile<br> (although Dialyzer is really quite different!)</li>
<li>Typeclasses are nice, Erlang doesn't have them</li>
<li>Erlang is probably (much) better for long-running systems</li>
</ul>
</section>
<section id="listsmap2" class="slide level1 big-code">
<h1>lists:map/2</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="fu">map(</span><span class="dt">F</span><span class="fu">,</span> <span class="fu">[</span><span class="dt">H</span><span class="fu">|</span><span class="dt">T</span><span class="fu">])</span> <span class="kw">-&gt;</span>
    <span class="fu">[</span><span class="dt">F</span><span class="fu">(</span><span class="dt">H</span><span class="fu">)|map(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">T</span><span class="fu">)];</span>
<span class="fu">map(</span><span class="dt">F</span><span class="fu">,</span> <span class="fu">[])</span> <span class="ch">when</span> <span class="fu">is_function(</span><span class="dt">F</span><span class="fu">,</span> <span class="dv">1</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">[].</span></code></pre>
</section>
<section id="map" class="slide level1 big-code">
<h1>map</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre>
</section>
<section id="listsmap2-typed" class="slide level1 big-code">
<h1>lists:map/2 (typed)</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">map(</span><span class="dt">Fun</span><span class="fu">,</span> <span class="dt">List1</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">List2</span> <span class="ch">when</span>
      <span class="dt">Fun</span> <span class="fu">::</span> <span class="kw">fun</span><span class="fu">((</span><span class="dt">A</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">B</span><span class="fu">),</span>
      <span class="dt">List1</span> <span class="fu">::</span> <span class="fu">[</span><span class="dt">A</span><span class="fu">],</span>
      <span class="dt">List2</span> <span class="fu">::</span> <span class="fu">[</span><span class="dt">B</span><span class="fu">],</span>
      <span class="dt">A</span> <span class="fu">::</span> <span class="fu">term(),</span>
      <span class="dt">B</span> <span class="fu">::</span> <span class="fu">term().</span>

<span class="fu">map(</span><span class="dt">F</span><span class="fu">,</span> <span class="fu">[</span><span class="dt">H</span><span class="fu">|</span><span class="dt">T</span><span class="fu">])</span> <span class="kw">-&gt;</span>
    <span class="fu">[</span><span class="dt">F</span><span class="fu">(</span><span class="dt">H</span><span class="fu">)|map(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">T</span><span class="fu">)];</span>
<span class="fu">map(</span><span class="dt">F</span><span class="fu">,</span> <span class="fu">[])</span> <span class="ch">when</span> <span class="fu">is_function(</span><span class="dt">F</span><span class="fu">,</span> <span class="dv">1</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">[].</span></code></pre>
</section>
<section id="map-typed" class="slide level1 big-code">
<h1>map (typed)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre>
</section>
<section id="listsfoldr3" class="slide level1 big-code">
<h1>lists:foldr/3</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">foldr(</span><span class="dt">Fun</span><span class="fu">,</span> <span class="dt">Acc0</span><span class="fu">,</span> <span class="dt">List</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">Acc1</span> <span class="ch">when</span>
      <span class="dt">Fun</span> <span class="fu">::</span> <span class="kw">fun</span><span class="fu">((</span><span class="dt">Elem</span> <span class="fu">::</span> <span class="dt">T</span><span class="fu">,</span> <span class="dt">AccIn</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">AccOut</span><span class="fu">),</span>
      <span class="dt">Acc0</span> <span class="fu">::</span> <span class="fu">term(),</span>
      <span class="dt">Acc1</span> <span class="fu">::</span> <span class="fu">term(),</span>
      <span class="dt">AccIn</span> <span class="fu">::</span> <span class="fu">term(),</span>
      <span class="dt">AccOut</span> <span class="fu">::</span> <span class="fu">term(),</span>
      <span class="dt">List</span> <span class="fu">::</span> <span class="fu">[</span><span class="dt">T</span><span class="fu">],</span>
      <span class="dt">T</span> <span class="fu">::</span> <span class="fu">term().</span>

<span class="fu">foldr(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">Accu</span><span class="fu">,</span> <span class="fu">[</span><span class="dt">Hd</span><span class="fu">|</span><span class="dt">Tail</span><span class="fu">])</span> <span class="kw">-&gt;</span>
    <span class="dt">F</span><span class="fu">(</span><span class="dt">Hd</span><span class="fu">,</span> <span class="fu">foldr(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">Accu</span><span class="fu">,</span> <span class="dt">Tail</span><span class="fu">));</span>
<span class="fu">foldr(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">Accu</span><span class="fu">,</span> <span class="fu">[])</span> <span class="ch">when</span> <span class="fu">is_function(</span><span class="dt">F</span><span class="fu">,</span> <span class="dv">2</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">Accu</span><span class="fu">.</span></code></pre>
</section>
<section id="foldr" class="slide level1 big-code">
<h1>foldr</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldr k z <span class="fu">=</span> go
   <span class="kw">where</span>
     go []     <span class="fu">=</span> z
     go (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> go ys</code></pre>
</section>
<section id="sum-type" class="slide level1 small-title big-code">
<h1>Sum Type</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">%% sum type, 3 possible values</span>
<span class="kw">-</span><span class="ch">type</span> <span class="fu">choice()</span> <span class="fu">::</span> <span class="ch">definitely</span>
                <span class="fu">|</span> <span class="ch">possibly</span>
                <span class="fu">|</span> <span class="ch">no_way</span><span class="fu">.</span></code></pre>
</section>
<section id="sum-type-1" class="slide level1 small-title big-code">
<h1>Sum Type</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sum type, 3 possible values</span>
<span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span>
            <span class="fu">|</span> <span class="dt">Possibly</span>
            <span class="fu">|</span> <span class="dt">NoWay</span></code></pre>
</section>
<section id="product-type" class="slide level1 small-title big-code">
<h1>Product Type</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">%% product type, 9 possible values (3 * 3)</span>
<span class="kw">-</span><span class="ch">type</span> <span class="fu">choices()</span> <span class="fu">::</span> <span class="fu">{choice(),</span> <span class="fu">choice()}.</span></code></pre>
</section>
<section id="product-type-1" class="slide level1 small-title big-code">
<h1>Product Type</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- product type, 9 possible values (3 * 3)</span>
<span class="kw">data</span> <span class="dt">Choices</span> <span class="fu">=</span> <span class="dt">Choices</span> <span class="dt">Choice</span> <span class="dt">Choice</span>

<span class="co">-- as a tuple with a type alias</span>
<span class="co">-- NOT THE SAME AS ABOVE! :)</span>
<span class="kw">type</span> <span class="dt">Choices</span> <span class="fu">=</span> (<span class="dt">Choice</span>, <span class="dt">Choice</span>)</code></pre>
</section>
<section id="product-type-record" class="slide level1 small-title big-code">
<h1>Product Type (Record)</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">%% record syntax</span>
<span class="kw">-</span><span class="fu">record(</span><span class="ch">choices</span><span class="fu">,</span>
        <span class="ch">fst_choice</span> <span class="fu">::</span> <span class="fu">choice(),</span>
        <span class="ch">snd_choice</span> <span class="fu">::</span> <span class="fu">choice()).</span>

<span class="co">%% getters need to be implemented manually</span>
<span class="kw">-</span><span class="ch">spec</span> <span class="fu">fst_choice(#</span><span class="ch">choices</span><span class="fu">{})</span> <span class="kw">-&gt;</span> <span class="fu">choice().</span>
<span class="fu">fst_choice(#</span><span class="ch">choices</span><span class="fu">{</span><span class="ch">fst_choices</span><span class="kw">=</span><span class="dt">X</span><span class="fu">})</span> <span class="kw">-&gt;</span> <span class="dt">X</span><span class="fu">.</span>

<span class="kw">-</span><span class="ch">spec</span> <span class="fu">snd_choice(#</span><span class="ch">choices</span><span class="fu">{})</span> <span class="kw">-&gt;</span> <span class="fu">choice().</span>
<span class="fu">snd_choice(#</span><span class="ch">choices</span><span class="fu">{</span><span class="ch">snd_choices</span><span class="kw">=</span><span class="dt">X</span><span class="fu">})</span> <span class="kw">-&gt;</span> <span class="dt">X</span><span class="fu">.</span></code></pre>
</section>
<section id="product-type-record-1" class="slide level1 small-title big-code">
<h1>Product Type (Record)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- record syntax defines accessors automatically</span>
<span class="kw">data</span> <span class="dt">Choices</span> <span class="fu">=</span>
  <span class="dt">Choices</span> {<span class="ot"> fstChoice ::</span> <span class="dt">Choice</span>
          ,<span class="ot"> sndChoice ::</span> <span class="dt">Choice</span>
          }

<span class="co">-- these getters are automatically defined</span>
<span class="ot">fstChoice ::</span> <span class="dt">Choices</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span>
fstChoice (<span class="dt">Choices</span> { fstChoice <span class="fu">=</span> x }) <span class="fu">=</span> x

<span class="ot">sndChoice ::</span> <span class="dt">Choices</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span>
sndChoice (<span class="dt">Choices</span> { sndChoice <span class="fu">=</span> x }) <span class="fu">=</span> x</code></pre>
</section>
<section id="abstract-data-type" class="slide level1 small-title big-code">
<h1>Abstract Data Type</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">%% abstract data type for a list</span>
<span class="kw">-</span><span class="ch">type</span> <span class="fu">cons(</span><span class="dt">A</span><span class="fu">)</span> <span class="fu">::</span> <span class="ch">nil</span>
               <span class="fu">|</span> <span class="fu">{</span><span class="ch">cons</span><span class="fu">,</span> <span class="dt">A</span><span class="fu">,</span> <span class="fu">cons(</span><span class="dt">A</span><span class="fu">)}.</span></code></pre>
</section>
<section id="abstract-data-type-1" class="slide level1 small-title big-code">
<h1>Abstract Data Type</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- abstract data type for a list</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span>
            <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre>
</section>
<section id="types-and-constructors-1" class="slide level1 small-title big-code highlight-type">
<h1></h1>
<h1>
<span class="hl-type">Types</span> and <span class="hl-constructor">Constructors</span>
</h1>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt hl-type">Choice</span> <span class="fu">=</span> <span class="dt hl-constructor">Definitely</span>
            <span class="fu">|</span> <span class="dt hl-constructor">Possibly</span>
            <span class="fu">|</span> <span class="dt hl-constructor">NoWay</span>

<span class="kw">data</span> <span class="dt hl-type">Choices</span> <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> <span class="dt hl-type">Choice</span> <span class="dt hl-type">Choice</span>

<span class="ot">mkChoices ::</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choices</span>
mkChoices a b <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> a b

<span class="ot">fstChoice ::</span> <span class="dt hl-type">Choices</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span>
fstChoice (<span class="dt hl-constructor">Choices</span> a _) <span class="fu">=</span> a</code></pre>

</section>
<section id="types-and-constructors-2" class="slide level1 small-title big-code highlight-constructor">
<h1></h1>
<h1>
<span class="hl-type">Types</span> and <span class="hl-constructor">Constructors</span>
</h1>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt hl-type">Choice</span> <span class="fu">=</span> <span class="dt hl-constructor">Definitely</span>
            <span class="fu">|</span> <span class="dt hl-constructor">Possibly</span>
            <span class="fu">|</span> <span class="dt hl-constructor">NoWay</span>

<span class="kw">data</span> <span class="dt hl-type">Choices</span> <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> <span class="dt hl-type">Choice</span> <span class="dt hl-type">Choice</span>

<span class="ot">mkChoices ::</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choices</span>
mkChoices a b <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> a b

<span class="ot">fstChoice ::</span> <span class="dt hl-type">Choices</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span>
fstChoice (<span class="dt hl-constructor">Choices</span> a _) <span class="fu">=</span> a</code></pre>

</section>
<section id="using-types" class="slide level1 big-code">
<h1>Using Types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Values can be annotated in-line</span>
<span class="dv">2</span> <span class="fu">^</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)

<span class="co">-- Bindings can be annotated</span>
<span class="ot">success ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="co">-- Constructors are values</span>
<span class="co">-- (and product constructors are functions)</span>
success x <span class="fu">=</span> <span class="dt">Just</span> x

<span class="co">-- Constructors can be pattern matched</span>
<span class="co">-- _ is a wildcard</span>
<span class="kw">case</span> success <span class="dt">True</span> <span class="kw">of</span>
  <span class="dt">Just</span> <span class="dt">True</span> <span class="ot">-&gt;</span> ()
  _         <span class="ot">-&gt;</span> ()</code></pre>
</section>
<section id="pattern-matching" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">is_just({</span><span class="ch">just</span><span class="fu">,</span> <span class="dt">A</span><span class="fu">}</span> <span class="fu">|</span> <span class="ch">nothing</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">boolean().</span>
<span class="fu">is_just({</span><span class="ch">just</span><span class="fu">,</span> <span class="dt">_</span><span class="fu">})</span> <span class="kw">-&gt;</span>
    <span class="ch">true</span><span class="fu">;</span>
<span class="fu">is_just(</span><span class="ch">nothing</span><span class="fu">)</span> <span class="kw">-&gt;</span>
    <span class="ch">false</span><span class="fu">.</span></code></pre>
</section>
<section id="pattern-matching-1" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isJust (<span class="dt">Just</span> _) <span class="fu">=</span> <span class="dt">True</span>
isJust <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="pattern-matching-2" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<p>Erlang's pattern matching allows non-linear patterns.</p>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">is_equal(</span><span class="dt">A</span><span class="fu">,</span> <span class="dt">A</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">boolean()</span> <span class="ch">when</span>
      <span class="dt">A</span> <span class="fu">::</span> <span class="fu">term().</span>
<span class="fu">is_equal(</span><span class="dt">A</span><span class="fu">,</span> <span class="dt">A</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="ch">true</span><span class="fu">;</span>
<span class="fu">is_equal(</span><span class="dt">_</span><span class="fu">,</span> <span class="dt">_</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="ch">false</span><span class="fu">.</span></code></pre>
</section>
<section id="pattern-matching-3" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<p>Haskell's... does not.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isEqual ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEqual a b <span class="fu">=</span> undefined</code></pre>
<blockquote>
This isn't even possible! Only constructors can be pattern matched. Types have no built-in equality.
</blockquote>

</section>
<section id="infix-and-prefix" class="slide level1 big-code">
<h1>`Infix` and (Prefix)</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">%% Symbolic operators can be used</span>
<span class="co">%% as functions from the erlang module</span>
<span class="ch">erlang</span><span class="fu">:</span><span class="ch">&#39;+&#39;</span><span class="fu">(</span><span class="dt">A</span><span class="fu">,</span> <span class="dt">B</span><span class="fu">).</span></code></pre>
<blockquote>
Erlang doesn't have user-defined infix operators
</blockquote>

</section>
<section id="infix-and-prefix-1" class="slide level1 big-code">
<h1>`Infix` and (Prefix)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Symbolic operators can be used</span>
<span class="co">-- prefix when in (parentheses)</span>
(<span class="fu">+</span>) a b

<span class="co">-- Named functions can be used</span>
<span class="co">-- infix when in `backticks`</span>
x <span class="ot">`elem`</span> xs

<span class="co">-- infixl, infixr define associativity</span>
<span class="co">-- and precedence (0 lowest, 9 highest)</span>
<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">`append`</span>
a <span class="ot">`append`</span> b <span class="fu">=</span> a <span class="fu">++</span> b</code></pre>
</section>
<section id="functions-lambdas" class="slide level1 big-code">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">add(integer(),</span> <span class="fu">integer())</span> <span class="kw">-&gt;</span> <span class="fu">integer().</span>
<span class="fu">add(</span><span class="dt">X</span><span class="fu">,</span> <span class="dt">Acc</span><span class="fu">)</span> <span class="kw">-&gt;</span>
    <span class="dt">X</span> <span class="kw">+</span> <span class="dt">Acc</span><span class="fu">.</span>

<span class="kw">-</span><span class="ch">spec</span> <span class="fu">sum_fun([integer()])</span> <span class="kw">-&gt;</span> <span class="fu">integer().</span>
<span class="fu">sum_fun(</span><span class="dt">Xs</span><span class="fu">)</span> <span class="kw">-&gt;</span>
    <span class="fu">lists:foldl(</span><span class="kw">fun</span> <span class="ch">add</span><span class="kw">/</span><span class="dv">2</span><span class="fu">,</span> <span class="dv">0</span><span class="fu">,</span> <span class="dt">Xs</span><span class="fu">).</span>

<span class="kw">-</span><span class="ch">spec</span> <span class="fu">sum_lambda([integer()])</span> <span class="kw">-&gt;</span> <span class="fu">integer().</span>
<span class="fu">sum_lambda(</span><span class="dt">Xs</span><span class="fu">)</span> <span class="kw">-&gt;</span>
    <span class="fu">lists:foldl(</span>
        <span class="kw">fun</span> <span class="fu">(</span><span class="dt">X</span><span class="fu">,</span> <span class="dt">Acc</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="dt">X</span> <span class="kw">+</span> <span class="dt">Acc</span> <span class="kw">end</span><span class="fu">,</span>
        <span class="dv">0</span><span class="fu">,</span>
        <span class="dt">Xs</span><span class="fu">).</span></code></pre>
</section>
<section id="functions-lambdas-1" class="slide level1 big-code">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun xs <span class="fu">=</span> foldl add <span class="dv">0</span> xs

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda xs <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu">+</span> x) <span class="dv">0</span> xs</code></pre>
</section>
<section id="functions-lambdas-2" class="slide level1 big-code">
<h1>Functions &amp; Lambdas</h1>
<ul>
<li>Haskell <em>only</em> has functions of one argument</li>
<li><code>a -&gt; b -&gt; c</code> is really <code>a -&gt; (b -&gt; c)</code></li>
<li><code>f a b</code> is really <code>(f a) b</code></li>
<li>Let's leverage that…</li>
</ul>
</section>
<section id="functions-lambdas-3" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="hl">xs</span> <span class="fu">=</span> foldl add <span class="dv">0</span> <span class="hl">xs</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="hl">xs</span> <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu">+</span> x) <span class="dv">0</span> <span class="hl">xs</span></code></pre>

</section>
<section id="functions-lambdas-4" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu hl">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu hl">+</span> x) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-5" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc <span class="hl">x</span> <span class="fu">=</span> <span class="fu">(+)</span> acc <span class="hl">x</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\acc <span class="hl">x</span> <span class="ot">-&gt;</span> <span class="fu">(+)</span> acc <span class="hl">x</span>) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-6" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add <span class="hl">acc</span> <span class="fu">=</span> <span class="fu">(+)</span> <span class="hl">acc</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\<span class="hl">acc</span> <span class="ot">-&gt;</span> <span class="fu">(+)</span> <span class="hl">acc</span>) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-7" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add <span class="fu">=</span> <span class="fu">(+)</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl <span class="fu">(+)</span> <span class="dv">0</span></code></pre>

</section>
<section id="guards" class="slide level1 big-code">
<h1>Guards</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">is_negative(number())</span> <span class="kw">-&gt;</span> <span class="fu">boolean().</span>
<span class="fu">is_negative(</span><span class="dt">X</span><span class="fu">)</span> <span class="ch">when</span> <span class="dt">X</span> <span class="kw">&lt;</span> <span class="dv">0</span> <span class="kw">-&gt;</span>
  <span class="ch">true</span><span class="fu">;</span>
<span class="fu">is_negative(</span><span class="dt">_</span><span class="fu">)</span> <span class="kw">-&gt;</span>
  <span class="ch">false</span><span class="fu">.</span></code></pre>
</section>
<section id="guards-1" class="slide level1 big-code">
<h1>Guards</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isNegative ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isNegative x
  <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="dt">True</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="guards-2" class="slide level1 big-code">
<h1>Guards</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isNegative ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isNegative x
  <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="dt">True</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">absoluteValue ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
absoluteValue x
  <span class="fu">|</span> isNegative x <span class="fu">=</span> <span class="fu">-</span>x
  <span class="fu">|</span> otherwise    <span class="fu">=</span> x</code></pre>
</section>
<section id="built-in-types" class="slide level1 big-code small-title">
<h1>Built-in types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- (), pronounced &quot;unit&quot;</span>
<span class="ot">unit ::</span> ()
unit <span class="fu">=</span> ()

<span class="co">-- Char</span>
<span class="ot">someChar ::</span> <span class="dt">Char</span>
someChar <span class="fu">=</span> <span class="ch">&#39;x&#39;</span>

<span class="co">-- Instances of Num typeclass</span>
<span class="ot">someDouble ::</span> <span class="dt">Double</span>
someDouble <span class="fu">=</span> <span class="dv">1</span>

<span class="co">-- Instances of Fractional typeclass</span>
<span class="ot">someRatio ::</span> <span class="dt">Rational</span>
someRatio <span class="fu">=</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">2345</span></code></pre>
</section>
<section id="lists-tuples" class="slide level1 big-code small-title">
<h1>Lists &amp; Tuples</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="fu">some_list()</span> <span class="kw">-&gt;</span>
    <span class="fu">[</span><span class="dv">1</span><span class="fu">,</span> <span class="dv">2</span><span class="fu">,</span> <span class="dv">3</span><span class="fu">].</span>

<span class="fu">some_other_list()</span> <span class="kw">-&gt;</span>
    <span class="fu">[</span><span class="dv">4</span> <span class="fu">|</span> <span class="fu">[</span><span class="dv">5</span> <span class="fu">|</span> <span class="fu">[</span><span class="dv">6</span> <span class="fu">|</span> <span class="fu">[]]]].</span>

<span class="fu">some_tuple()</span> <span class="kw">-&gt;</span>
    <span class="fu">{</span><span class="dv">10</span><span class="fu">,</span> <span class="dv">$4</span><span class="fu">}.</span>

<span class="fu">some_string()</span> <span class="kw">-&gt;</span>
    <span class="st">&quot;foo&quot;</span><span class="fu">.</span></code></pre>
</section>
<section id="lists-tuples-1" class="slide level1 big-code small-title">
<h1>Lists &amp; Tuples</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [a], type can be written prefix as `[] a`</span>
someList,<span class="ot"> someOtherList ::</span> [<span class="dt">Int</span>]
someList <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
someOtherList <span class="fu">=</span> <span class="dv">4</span> <span class="fu">:</span> <span class="dv">5</span> <span class="fu">:</span> <span class="dv">6</span> <span class="fu">:</span> []
dontWriteThis <span class="fu">=</span> (<span class="fu">:</span>) <span class="dv">4</span> (<span class="dv">5</span> <span class="fu">:</span> (<span class="fu">:</span>) <span class="dv">6</span> [])

<span class="co">-- (a, b), can be written prefix as `(,) a b`</span>
someTuple,<span class="ot"> someOtherTuple ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
someTuple <span class="fu">=</span> (<span class="dv">10</span>, <span class="ch">&#39;4&#39;</span>)
someOtherTuple <span class="fu">=</span> (,) <span class="dv">4</span> <span class="ch">&#39;2&#39;</span>

<span class="co">-- [Char], also known as String</span>
<span class="co">-- (also see the OverloadedStrings extension)</span>
<span class="ot">someString ::</span> <span class="dt">String</span>
someString <span class="fu">=</span> <span class="st">&quot;foo&quot;</span></code></pre>
</section>
<section id="typeclass-syntax" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<ul>
<li><p>Erlang doesn't have typeclasses.</p></li>
<li><p>Elixir has Protocols, which are closer, but they are also not typeclasses.</p></li>
</ul>
</section>
<section id="typeclass-syntax-1" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Equals</span> a <span class="kw">where</span>
<span class="ot">  isEqual ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Equals</span> <span class="dt">Choice</span> <span class="kw">where</span>
  isEqual <span class="dt">Definitely</span> <span class="dt">Definitely</span> <span class="fu">=</span> <span class="dt">True</span>
  isEqual <span class="dt">Possibly</span>   <span class="dt">Possibly</span>   <span class="fu">=</span> <span class="dt">True</span>
  isEqual <span class="dt">NoWay</span>      <span class="dt">NoWay</span>      <span class="fu">=</span> <span class="dt">True</span>
  isEqual _          _          <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> (<span class="dt">Equals</span> a) <span class="ot">=&gt;</span> <span class="dt">Equals</span> [a] <span class="kw">where</span>
  isEqual (a<span class="fu">:</span>as) (b<span class="fu">:</span>bs) <span class="fu">=</span> isEqual a b <span class="fu">&amp;&amp;</span>
                          isEqual as bs
  isEqual as     bs     <span class="fu">=</span> null as <span class="fu">&amp;&amp;</span> null bs</code></pre>
</section>
<section id="typeclass-syntax-2" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-</span>
<span class="co">class Eq a where</span>
<span class="co">  (==) :: a -&gt; a -&gt; Bool</span>
<span class="co">-}</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Choice</span> <span class="kw">where</span>
  <span class="dt">Definitely</span> <span class="fu">==</span> <span class="dt">Definitely</span> <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">Possibly</span>   <span class="fu">==</span> <span class="dt">Possibly</span>   <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">NoWay</span>      <span class="fu">==</span> <span class="dt">NoWay</span>      <span class="fu">=</span> <span class="dt">True</span>
  _          <span class="fu">==</span> _          <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="typeclass-syntax-3" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span>
            <span class="fu">|</span> <span class="dt">Possibly</span>
            <span class="fu">|</span> <span class="dt">NoWay</span>
            <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
</section>
<section id="typeclass-syntax-4" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span>
            <span class="fu">|</span> <span class="dt">Possibly</span>
            <span class="fu">|</span> <span class="dt">NoWay</span>
            <span class="kw">deriving</span> ( <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>
                     , <span class="dt">Show</span>, <span class="dt">Read</span> )</code></pre>
</section>
<section id="quickcheck" class="slide level1 big-code">
<h1>QuickCheck</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="fu">prop_itsthere()</span> <span class="kw">-&gt;</span>
    <span class="fu">?</span><span class="dt">FORALL</span><span class="fu">(</span><span class="dt">I</span><span class="fu">,int(),</span>
        <span class="fu">[</span><span class="dt">I</span><span class="fu">]</span> <span class="kw">==</span> <span class="fu">queue:to_list(</span>
            <span class="fu">queue:cons(</span><span class="dt">I</span><span class="fu">,</span>
                <span class="fu">queue:new()))).</span></code></pre>
</section>
<section id="quickcheck-1" class="slide level1 big-code">
<h1>QuickCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Sequence</span> ((|&gt;), empty)
<span class="kw">import </span><span class="dt">Data.Foldable</span> (toList)

<span class="ot">prop_itsthere ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_itsthere i <span class="fu">=</span> [i] <span class="fu">==</span> toList (empty <span class="fu">|&gt;</span> i)</code></pre>
</section>
<section id="quickcheck-2" class="slide level1 big-code">
<h1>QuickCheck</h1>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
λ&gt; <span class="kw">import </span><span class="dt">Data.Foldable</span>
λ&gt; <span class="kw">import </span><span class="dt">Data.Sequence</span>
λ&gt; quickCheck (\i <span class="ot">-&gt;</span> [<span class="ot">i ::</span> <span class="dt">Int</span>] <span class="fu">==</span>
                       toList (empty <span class="fu">|&gt;</span> i))
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre>
</section>
<section id="do-syntax" class="slide level1 big-code highlight">
<h1>Do syntax</h1>
<!--
```erlang
-spec main([string()]) -> ok.
main(_Args) ->
    {ok, Secret} = file:read_file("/etc/passwd"),
    file:write_file("/tmp/passwd", Secret),
    ok.
```
-->

<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">main([string()])</span> <span class="kw">-&gt;</span> <span class="ch">ok</span><span class="fu">.</span>
<span class="fu">main(</span><span class="dt">_Args</span><span class="fu">)</span> <span class="kw">-&gt;</span>
  <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="dt">Secret</span><span class="fu">}</span> <span class="kw">=</span> <span class="fu">file:read_file(</span><span class="st">"/etc/passwd"</span><span class="fu">)<span class="hl">,</span></span>
  <span class="fu">file:write_file(</span><span class="st">"/tmp/passwd"</span><span class="fu">,</span> <span class="dt">Secret</span><span class="fu">)<span class="hl">,</span></span>
  <span class="ch">ok</span><span class="fu"><span class="hl">.</span></span></code></pre>

</section>
<section id="do-syntax-io" class="slide level1 big-code">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  secret <span class="ot">&lt;-</span> readFile <span class="st">&quot;/etc/passwd&quot;</span>
  writeFile <span class="st">&quot;/tmp/passwd&quot;</span> secret
  return ()</code></pre>
</section>
<section id="do-syntax-1" class="slide level1 big-code">
<h1>Do syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">do</span> m
<span class="co">-- desugars to:</span>
m

<span class="kw">do</span> a <span class="ot">&lt;-</span> m
   return a
<span class="co">-- desugars to:</span>
m <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> return a

<span class="kw">do</span> m
   return ()
<span class="co">-- desugars to:</span>
m <span class="fu">&gt;&gt;</span> return ()</code></pre>
</section>
<section id="do-syntax-io-1" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="hl"><span class="kw">do</span></span>
  <span class="hl">secret <span class="ot">&lt;-</span></span> readFile <span class="st">"/etc/passwd"</span>
  writeFile <span class="st">"/tmp/passwd"</span> secret
  return ()</code></pre>

</section>
<section id="do-syntax-io-2" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="hl">&gt;&gt;= \secret -> do</span>
  writeFile <span class="st">"/tmp/passwd"</span> secret
  return ()</code></pre>

</section>
<section id="do-syntax-io-3" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span> \secret <span class="ot">-></span>
  writeFile <span class="st">"/tmp/passwd"</span> secret <span class="hl">&gt;&gt;</span>
  return ()</code></pre>

</section>
<section id="do-syntax-io-4" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span><span class="hl"> \secret <span class="ot">-></span></span>
  writeFile <span class="st">"/tmp/passwd"</span> <span class="hl">secret</span></code></pre>

</section>
<section id="do-syntax-io-5" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span>
  writeFile <span class="st">"/tmp/passwd"</span></code></pre>

</section>
<section id="do-syntax-a" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="kw">-</span><span class="ch">spec</span> <span class="fu">flat_map(</span><span class="kw">fun</span><span class="fu">((</span><span class="dt">A</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">[</span><span class="dt">B</span><span class="fu">]),</span> <span class="fu">[</span><span class="dt">A</span><span class="fu">])</span> <span class="kw">-&gt;</span> <span class="fu">[</span><span class="dt">B</span><span class="fu">]</span> <span class="ch">when</span>
  <span class="dt">A</span> <span class="fu">::</span> <span class="fu">term(),</span>
  <span class="dt">B</span> <span class="fu">::</span> <span class="fu">term().</span>
<span class="fu">flat_map(</span><span class="dt">F</span><span class="fu">,</span> <span class="dt">Xs</span><span class="fu">)</span> <span class="kw">-&gt;</span> <span class="fu">[</span> <span class="dt">Y</span> <span class="fu">||</span> <span class="dt">X</span> <span class="kw">&lt;-</span> <span class="dt">Xs</span><span class="fu">,</span> <span class="dt">Y</span> <span class="kw">&lt;-</span> <span class="dt">F</span><span class="fu">(</span><span class="dt">X</span><span class="fu">)</span> <span class="fu">].</span></code></pre>
</section>
<section id="do-syntax-a-1" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> [ y <span class="fu">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> f x ]</code></pre>
</section>
<section id="do-syntax-a-2" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  y <span class="ot">&lt;-</span> f x
  return y</code></pre>
</section>
<section id="do-syntax-a-3" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  f x</code></pre>
</section>
<section id="do-syntax-a-4" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> f x</code></pre>
</section>
<section id="do-syntax-a-5" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> f</code></pre>
</section>
<section id="do-syntax-a-6" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> flip (<span class="fu">&gt;&gt;=</span>) f xs</code></pre>
</section>
<section id="do-syntax-a-7" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap <span class="fu">=</span> flip (<span class="fu">&gt;&gt;=</span>)</code></pre>
</section>
<section id="do-syntax-a-8" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap <span class="fu">=</span> (<span class="fu">=&lt;&lt;</span>)</code></pre>
</section>
<section id="key-features" class="slide level1">
<h1>Key Features</h1>
<ul>
<li>Interactive</li>
<li>Pure</li>
<li>Non-strict (lazy) evaluation</li>
<li>Types and typeclasses</li>
<li>Abstractions</li>
<li>Multi-paradigm</li>
</ul>
</section>
<section id="ghci" class="slide level1">
<h1>GHCi</h1>
<h2>
Interactive Haskell
</h2>

</section>
<section id="runhaskell" class="slide level1">
<h1></h1>
<pre class="sourceCode bash"><code class="sourceCode bash">
$ <span class="kw">runhaskell</span> --help
<span class="kw">Usage</span>: runghc [runghc flags] [GHC flags] module [program args]

<span class="kw">The</span> runghc flags are
    <span class="kw">-f</span> /path/to/ghc       Tell runghc where GHC is
    <span class="kw">--help</span>                Print this usage information
    <span class="kw">--version</span>             Print version number</code></pre>
</section>
<section id="ghci-start" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">$</span> ghci
<span class="dt">GHCi</span>, version <span class="dv">7</span><span class="fu">.</span><span class="dv">6</span><span class="fu">.</span><span class="dv">3</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help
<span class="dt">Loading</span> package ghc<span class="fu">-</span>prim <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package integer<span class="fu">-</span>gmp <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package base <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
h<span class="fu">&gt;</span> </code></pre>
</section>
<section id="ghci-t" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:t</code> shows type information
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>t map
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
h<span class="fu">&gt;</span> <span class="fu">:</span>t map (<span class="fu">+</span><span class="dv">1</span>)
map (<span class="fu">+</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> [b] <span class="ot">-&gt;</span> [b]
h<span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">&gt;&gt;=</span>)
<span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre>
</section>
<section id="ghci-i-typeclass" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows typeclass info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Num</span>
<span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span>
<span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  abs ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  signum ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a
    <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Integer</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Float</span> <span class="co">-- Defined in `GHC.Float&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Double</span> <span class="co">-- Defined in `GHC.Float&#39;</span></code></pre>
</section>
<section id="ghci-i-value" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows value info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>info map
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]   
<span class="co">-- Defined in `GHC.Base&#39;</span>
h<span class="fu">&gt;</span> <span class="fu">:</span>info (<span class="fu">&gt;&gt;=</span>)
<span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  <span class="fu">...</span>
    <span class="co">-- Defined in `GHC.Base&#39;</span>
<span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&gt;&gt;=</span></code></pre>
</section>
<section id="ghci-i-type" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows type info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> ghc<span class="fu">-</span>prim<span class="fu">:</span><span class="dt">GHC.Types.I</span><span class="st">#</span>
  ghc<span class="fu">-</span>prim<span class="fu">:</span><span class="dt">GHC.Prim.Int</span><span class="st">#</span>
  <span class="co">-- Defined in `ghc-prim:GHC.Types&#39;</span>
<span class="kw">instance</span> <span class="dt">Bounded</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Enum&#39;</span>
<span class="kw">instance</span> <span class="dt">Enum</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Enum&#39;</span>
<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Classes&#39;</span>
<span class="kw">instance</span> <span class="dt">Integral</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Real&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Classes&#39;</span>
<span class="kw">instance</span> <span class="dt">Read</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Read&#39;</span>
<span class="kw">instance</span> <span class="dt">Real</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Real&#39;</span>
<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Show&#39;</span></code></pre>
</section>
<section id="ghci-load-reload" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:l</code> load a module
</h2>
<h2>
<code>:r</code> to reload
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:!</span> echo <span class="ch">&#39;hello = print &quot;hello&quot;&#39;</span> <span class="fu">&gt;</span> Hello.hs
h<span class="fu">&gt;</span> <span class="fu">:</span>l <span class="dt">Hello</span>
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( Hello.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Main</span><span class="fu">.</span>
h<span class="fu">&gt;</span> hello
<span class="st">&quot;hello&quot;</span>
h<span class="fu">&gt;</span> <span class="fu">:!</span> echo <span class="ch">&#39;hello = print &quot;HELLO&quot;&#39;</span> <span class="fu">&gt;</span> Hello.hs
h<span class="fu">&gt;</span> <span class="fu">:</span>r
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( Hello.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Main</span><span class="fu">.</span>
h<span class="fu">&gt;</span> hello
<span class="st">&quot;HELLO&quot;</span></code></pre>
</section>
<section id="side-effects" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount1.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  input <span class="ot">&lt;-</span> getContents
  <span class="kw">let</span> wordCount <span class="fu">=</span> length (words input)
  print wordCount</code></pre>
</section>
<section id="side-effects-2" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount2.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  getContents <span class="fu">&gt;&gt;=</span> \input <span class="ot">-&gt;</span>
    <span class="kw">let</span> wordCount <span class="fu">=</span> length (words input)
    <span class="kw">in</span> print wordCount</code></pre>
</section>
<section id="side-effects-3" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount3.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> getContents <span class="fu">&gt;&gt;=</span> print <span class="fu">.</span> length <span class="fu">.</span> words</code></pre>
</section>
<section id="what.the" class="slide level1">
<h1>what.the <code>&gt;&gt;=</code>?</h1>
<ul>
<li><code>do</code> is just syntax sugar for the <code>&gt;&gt;=</code> (bind) operator.</li>
<li>IO is still purely functional, we are just building a graph of actions, <em>not</em> executing them in-place!</li>
<li>Starting from <code>main</code>, the Haskell runtime will <em>evaluate</em> these actions</li>
<li>It works much like continuation passing style, with a state variable for the current world state (behind the scenes)</li>
<li>There are ways to cheat and write code that is not pure, but you will have to go out of your way to do it</li>
</ul>
</section>
<section id="common-combinators" class="slide level1 big-code">
<h1>Common combinators</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Function composition</span>
<span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)

<span class="co">-- Function application (with a lower precedence)</span>
<span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$</span> x <span class="fu">=</span>  f x</code></pre>
</section>
<section id="pure" class="slide level1">
<h1>Pure</h1>
<ul>
<li>Haskell's purity implies referential transparency</li>
<li>This means that function invocation can be freely replaced with its return value without changing semantics</li>
<li>Fantastic for optimizations</li>
<li>Also enables equational reasoning, which makes it easier to prove code correct</li>
</ul>
</section>
<section id="compiler" class="slide level1">
<h1></h1>
<!--
https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
-->
<svg viewBox="0 0 1000 1000" class="full diagram">
  
<defs> <marker id="Triangle"
      viewBox="0 0 10 10" refX="0" refY="5" 
      markerUnits="strokeWidth"
      markerWidth="4" markerHeight="3"
      orient="auto"> <path d="M 0 0 L 10 5 L 0 10 z" /> </marker> </defs> <g class="right-title" transform="translate(1000, 20)"> <text>GHC compilation phases</text> </g> <g class="phase parse" transform="translate(500, 85)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Parse</text> </g> <g class="phase rename" transform="translate(500, 215)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Rename</text> </g> <g class="phase typecheck" transform="translate(500, 345)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Typecheck</text> </g> <g class="phase desugar" transform="translate(500, 475)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Desugar</text> </g> <g class="phase optimize" transform="translate(500, 605)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <path d="M 65,35 a 160,80 0 1,0 40,-80" marker-end="url(#Triangle)"/> <text x="220" class="outside">Core</text> <ellipse rx="120" ry="35"/> <text>Optimize</text> </g> <g class="phase codegen" transform="translate(500, 735)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Code gen</text> </g> <g class="phase llvm" transform="translate(500, 865)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>LLVM</text> <line y1="45" y2="65" marker-end="url(#Triangle)" /> </g>
</svg>

</section>
<section id="optimizations" class="slide level1">
<h1>Optimizations</h1>
<!--
http://stackoverflow.com/questions/12653787/what-optimizations-can-ghc-be-expected-to-perform-reliably 
http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
-->

<ul>
<li>Common sub-expression elimination</li>
<li>Inlining (cross-module too!)</li>
<li>Specialize</li>
<li>Float out</li>
<li>Float inwards</li>
<li>Demand analysis</li>
<li>Worker/Wrapper binds</li>
<li>Liberate case</li>
<li>Call-pattern specialization (SpecConstr)</li>
</ul>
</section>
<section id="ghc-rules" class="slide level1">
<h1>GHC RULES!</h1>
<!--
http://www.haskell.org/haskellwiki/Playing_by_the_rules
http://www.haskell.org/haskellwiki/GHC/Using_rules
https://ghc.haskell.org/trac/ghc/wiki/RewriteRules
-->

<ul>
<li>Term rewriting engine</li>
<li>RULES pragma allows <em>library defined optimizations</em></li>
<li>Used to great effect for short cut fusion</li>
<li>Example: <code>map f (map g xs) = map (f . g) xs</code></li>
<li>Prevent building of intermediate data structures</li>
<li>Commonly used for lists, Text, ByteString, etc.</li>
<li>Great incentive to write high-level code!</li>
<li>ANY LIBRARY CAN USE THIS!</li>
</ul>
</section>
<section id="ghc-rules-ex" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span></code></pre>
</section>
<section id="ghc-rules-1" class="slide level1 big-code">
<h1>GHC RULES</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>, break)

<span class="ot">splitLine ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)
splitLine <span class="fu">=</span> break (<span class="fu">==</span><span class="ch">&#39;\n&#39;</span>)</code></pre>
</section>
<section id="ghc-rules-2" class="slide level1 big-code">
<h1>GHC RULES</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>, break)

<span class="ot">splitLine ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)
splitLine <span class="fu">=</span> breakByte <span class="ch">&#39;\n&#39;</span></code></pre>
</section>
<section id="lazy" class="slide level1">
<h1>Lazy</h1>
<ul>
<li>Call by need (outside in), not call by value (inside out)</li>
<li>Non-strict evaluation separates equation from execution</li>
<li>No need for special forms for control flow, no value restriction</li>
<li>Enables infinite or cyclic data structures</li>
<li>Can skip unused computation (better minimum bounds)</li>
</ul>
</section>
<section id="lazy-ramsey" class="slide level1">
<h1></h1>
<figure>
<img src="img/ramsey-lazy-2013.jpg" alt="lazy" /><figcaption>lazy</figcaption>
</figure>
</section>
<section id="call-by-need" class="slide level1">
<h1>Call by need</h1>
<!--
https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
http://research.microsoft.com/apps/pubs/default.aspx?id=67083
-->

<ul>
<li>Expressions are translated into a graph (not a tree!)</li>
<li>Evaluated with STG (Spineless Tagless G-Machine)</li>
<li>Pattern matching forces evaluation</li>
</ul>
</section>
<section id="non-strict-evaluation" class="slide level1 big-code">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [1..] is an infinite list, [1, 2, 3, ...]</span>
print (head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>]))</code></pre>
</section>
<section id="non-strict-evaluation-1" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [1..] is an infinite list, [1, 2, 3, ...]</span>
<span class="hl">print (</span>head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>])<span class="hl">)</span>
<span class="co">-- Outside in, print x = putStrLn (show x)</span>
<span class="hl">putStrLn (show (</span>head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>]<span class="hl">))</span></code></pre>

</section>
<section id="non-strict-evaluation-2" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Outside in, print x = putStrLn (show x)</span>
putStrLn (show (<span class="hl2">head (<span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>) <span class="hl">[<span class="dv">1</span><span class="fu">..</span>]</span>)</span>)</span>
<span class="co">-- head (x:_) = x</span>
<span class="co">-- map f (x:xs) = f x : map f xs</span>
<span class="co">-- desugar [1..] syntax</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>) (<span class="hl">enumFrom <span class="dv">1</span></span>))))</code></pre>

</section>
<section id="non-strict-evaluation-3" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- desugar [1..] syntax</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>) (<span class="hl">enumFrom <span class="dv">1</span></span>))))
<span class="co">-- enumFrom n = n : enumFrom (succ n)</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>)
                          (<span class="hl"><span class="dv">1</span> <span class="fu">:</span> enumFrom (succ <span class="dv">1</span>)</span>))))</code></pre>

</section>
<section id="non-strict-evaluation-4" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- enumFrom n = n : enumFrom (succ n)</span>
putStrLn (show (head (<span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>)</span>
                          <span class="hl1">(<span class="hl"><span class="dv">1</span> <span class="fu">:</span></span> enumFrom (succ <span class="dv">1</span>))</span>)))
<span class="co">-- apply map</span>
putStrLn (show (head
                  (<span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>) <span class="fu">:</span></span>
                   <span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>) (enumFrom (succ <span class="dv">1</span>))</span>)))</code></pre>

</section>
<section id="non-strict-evaluation-5" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- apply map</span>
putStrLn (show (<span class="hl1">head (<span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span> <span class="fu">:</span> …)</span>))
<span class="co">-- apply head</span>
putStrLn (show <span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span>)</code></pre>

</section>
<section id="non-strict-evaluation-6" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- apply head</span>
putStrLn (show <span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span>)
<span class="co">-- show pattern matches on its argument</span>
putStrLn (show <span class="hl"><span class="dv">2</span></span>)</code></pre>

</section>
<section id="non-strict-evaluation-7" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- show pattern matches on its argument</span>
putStrLn (<span class="hl">show <span class="dv">2</span></span>)
<span class="co">-- apply show</span>
putStrLn <span class="hl"><span class="st">"2"</span></span></code></pre>

</section>
<section id="control-flow" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">if&#39; ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
if&#39; cond a b <span class="fu">=</span> <span class="kw">case</span> cond <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> a
  <span class="dt">False</span> <span class="ot">-&gt;</span> b

<span class="ot">(&amp;&amp;) ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
a <span class="fu">&amp;&amp;</span> b <span class="fu">=</span> <span class="kw">case</span> a <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> b
  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">False</span>

const<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
const x <span class="fu">=</span> \_ <span class="ot">-&gt;</span> x</code></pre>
</section>
<section id="infinite-programming" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">fib ::</span> [<span class="dt">Integer</span>]
fib <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fib (tail fib)

cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs

iterate<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
iterate f x <span class="fu">=</span> x <span class="fu">:</span> iterate f (f x)

takeWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
takeWhile _ [] <span class="fu">=</span> []
takeWhile p (x<span class="fu">:</span>xs)
  <span class="fu">|</span> p x       <span class="fu">=</span> x <span class="fu">:</span> takeWhile p xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> []</code></pre>
</section>
<section id="types" class="slide level1">
<h1>Types</h1>
<ul>
<li>Enforce constraints at compile time</li>
<li>No NULL</li>
<li>Can have parametric polymorphism and/or recursion</li>
<li>Built-in types are not special (other than syntax)</li>
<li>Typeclasses for <em>ad hoc</em> polymorphism (overloading)</li>
</ul>
</section>
<section id="constraints" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="kw">let</span> f x <span class="fu">=</span> head <span class="dt">True</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">23</span><span class="fu">:</span><span class="dv">16</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> <span class="ot">`[a0]&#39; with actual type `</span><span class="dt">Bool&#39;</span>
    <span class="dt">In</span> the first argument <span class="kw">of</span> <span class="ot">`head&#39;, namely `</span><span class="dt">True&#39;</span>
    <span class="dt">In</span> the expression<span class="fu">:</span> head <span class="dt">True</span>
    <span class="dt">In</span> an equation for <span class="ot">`f&#39;: f x = head True</span>

<span class="ot">h&gt; let f x = heads True</span>

<span class="ot">&lt;interactive&gt;:24:11:</span>
<span class="ot">    Not in scope: `</span>heads&#39;
    <span class="dt">Perhaps</span> you meant one <span class="kw">of</span> these<span class="fu">:</span>
      <span class="ot">`reads&#39; (imported from Prelude), `</span>head&#39; (imported from <span class="dt">Prelude</span>)</code></pre>
</section>
<section id="bottoms" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> x <span class="kw">in</span> x
<span class="co">-- Infinite recursion, not a fun case to deal with!</span>

h<span class="fu">&gt;</span> <span class="kw">case</span> <span class="dt">False</span> <span class="kw">of</span> <span class="dt">True</span> <span class="ot">-&gt;</span> ()
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">29</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">24</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> <span class="kw">case</span>

h<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list

h<span class="fu">&gt;</span> error <span class="st">&quot;this throws an exception&quot;</span>
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> this throws an exception

h<span class="fu">&gt;</span> undefined
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre>
</section>
<section id="polymorphic" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Polymorphic and recursive</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a
            <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)
            <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">listMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
listMap _ <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">Nil</span>
listMap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (listMap f xs)

<span class="ot">treeToList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
treeToList root <span class="fu">=</span> go root <span class="dt">Nil</span>
  <span class="kw">where</span>
    <span class="co">-- Note that `go` returns a function!</span>
    go (<span class="dt">Leaf</span> x)     <span class="fu">=</span> <span class="dt">Cons</span> x
    go (<span class="dt">Branch</span> l r) <span class="fu">=</span> go l <span class="fu">.</span> go r</code></pre>
</section>
<section id="typeclasses" class="slide level1">
<h1>Typeclasses</h1>
<ul>
<li>Used for many of the Prelude operators and numeric literals</li>
<li>Ad hoc polymorphism (overloading)</li>
<li>Many built-in typeclasses can be automatically derived (Eq, Ord, Enum, Bounded, Show, and Read)!</li>
</ul>
</section>
<section id="typeclass-example" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">module</span> <span class="dt">List</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>

<span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  (<span class="dt">Cons</span> a as) <span class="fu">==</span> (<span class="dt">Cons</span> b bs) <span class="fu">=</span> a <span class="fu">==</span> b <span class="fu">&amp;&amp;</span> as <span class="fu">==</span> bs
  <span class="dt">Nil</span>         <span class="fu">==</span> <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">True</span>
  _           <span class="fu">==</span> _           <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span>
  fmap _ <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">Nil</span>
  fmap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (fmap f xs)</code></pre>
</section>
<section id="typeclass-example-2" class="slide level1 big-code">
<h1></h1>
<!-- http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="kw">module</span> <span class="dt">List</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>)</code></pre>
</section>
<section id="newtype" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">import </span><span class="dt">Data.List</span> (sort)

<span class="kw">newtype</span> <span class="dt">Down</span> a <span class="fu">=</span> <span class="dt">Down</span> {<span class="ot"> unDown ::</span> a }
                 <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">Down</span> a) <span class="kw">where</span>
  compare (<span class="dt">Down</span> a) (<span class="dt">Down</span> b) <span class="fu">=</span> <span class="kw">case</span> compare a b <span class="kw">of</span>
    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">GT</span>
    <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">EQ</span>
    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">LT</span>

<span class="ot">reverseSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
reverseSort <span class="fu">=</span> map unDown <span class="fu">.</span> sort <span class="fu">.</span> map <span class="dt">Down</span></code></pre>
</section>
<section id="abstractions" class="slide level1">
<h1>Abstractions</h1>
<dl>
<dt>Monoid</dt>
<dd>Has an identity and an associative operation
</dd>
<dt>Functor</dt>
<dd>Anything that can be mapped over (preserving structure)
</dd>
<dt>Applicative</dt>
<dd>Functor, but can apply function from inside
</dd>
<dt>Monad</dt>
<dd>Applicative, but can return any structure
</dd>
</dl>
</section>
<section id="monoid" class="slide level1">
<h1>Monoid</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">  mempty ::</span> a
<span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span>
  mempty <span class="fu">=</span> []
  mappend <span class="fu">=</span> (<span class="fu">++</span>)

<span class="kw">infixr</span> <span class="dv">6</span> <span class="fu">&lt;&gt;</span>
<span class="ot">(&lt;&gt;) ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
(<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> mappend</code></pre>
</section>
<section id="functor" class="slide level1">
<h1>Functor</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap <span class="fu">=</span> map

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)
  fmap _ <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;$&gt;</span>
<span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> fmap</code></pre>
</section>
<section id="applicative" class="slide level1">
<h1>Applicative</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a
  <span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;*&gt;</span>
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span>
  pure x <span class="fu">=</span> [x]
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> concatMap (\f <span class="ot">-&gt;</span> map f xs) fs

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Just</span>
  <span class="dt">Just</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> x <span class="fu">=</span> <span class="dt">Just</span> (f x)
  _      <span class="fu">&lt;*&gt;</span> _      <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
</section>
<section id="monad" class="slide level1">
<h1>Monad</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  (&gt;&gt;)  ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
  ma <span class="fu">&gt;&gt;</span> mb <span class="fu">=</span> ma <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> mb

<span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
  return <span class="fu">=</span> pure
  m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> concatMap f m

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  return <span class="fu">=</span> pure
  <span class="dt">Just</span> x  <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x
  <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
</section>
<section id="parser-combinators" class="slide level1">
<h1>Parser Combinators</h1>
</section>
<section id="parsing" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">SJSON</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (concat)
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>, concat)
<span class="kw">import </span><span class="dt">Data.Attoparsec.Text</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">JSON</span> <span class="fu">=</span> <span class="dt">JArray</span> [<span class="dt">JSON</span>]
          <span class="fu">|</span> <span class="dt">JObject</span> [(<span class="dt">Text</span>, <span class="dt">JSON</span>)]
          <span class="fu">|</span> <span class="dt">JText</span> <span class="dt">Text</span>
          <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">pJSON ::</span> <span class="dt">Parser</span> <span class="dt">JSON</span>
pJSON <span class="fu">=</span> choice [ pText, pObject, pArray ]
  <span class="kw">where</span>
    pString <span class="fu">=</span> concat <span class="fu">&lt;$&gt;</span> <span class="st">&quot;\&quot;&quot;</span> <span class="fu">.*&gt;</span> many pStringChunk <span class="fu">&lt;*.</span> <span class="st">&quot;\&quot;&quot;</span>
    pStringChunk <span class="fu">=</span> choice [ <span class="st">&quot;\\\&quot;&quot;</span> <span class="fu">.*&gt;</span> pure <span class="st">&quot;\&quot;&quot;</span>
                          , takeWhile1 (not <span class="fu">.</span> (<span class="ot">`elem`</span> <span class="st">&quot;\\\&quot;&quot;</span>))
                          , <span class="st">&quot;\\&quot;</span> ]
    pText <span class="fu">=</span> <span class="dt">JText</span> <span class="fu">&lt;$&gt;</span> pString
    pPair <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> pString <span class="fu">&lt;*.</span> <span class="st">&quot;:&quot;</span> <span class="fu">&lt;*&gt;</span> pJSON
    pObject <span class="fu">=</span> <span class="dt">JObject</span> <span class="fu">&lt;$&gt;</span> <span class="st">&quot;{&quot;</span> <span class="fu">.*&gt;</span> (pPair <span class="ot">`sepBy`</span> <span class="st">&quot;,&quot;</span>) <span class="fu">&lt;*.</span> <span class="st">&quot;}&quot;</span>
    pArray <span class="fu">=</span> <span class="dt">JArray</span> <span class="fu">&lt;$&gt;</span> <span class="st">&quot;[&quot;</span> <span class="fu">.*&gt;</span> (pJSON <span class="ot">`sepBy`</span> <span class="st">&quot;,&quot;</span>) <span class="fu">&lt;*.</span> <span class="st">&quot;]&quot;</span></code></pre>
</section>
<section id="foreign-function-interface" class="slide level1">
<h1>Foreign Function Interface</h1>
</section>
<section id="ffi" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class="kw">import </span><span class="dt">Foreign.C.Types</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>

foreign <span class="kw">import </span>ccall unsafe &quot;stdlib.h rand&quot;
<span class="ot">     c_rand ::</span> <span class="dt">IO</span> <span class="dt">CUInt</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> replicateM_ <span class="dv">20</span> (c_rand <span class="fu">&gt;&gt;=</span> print)</code></pre>
</section>
<section id="parallel-programming" class="slide level1">
<h1>Parallel Programming</h1>
</section>
<section id="parallel-flip-image" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- FlipImage.hs</span>
<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">Data.Array.Repa</span> <span class="kw">hiding</span> ((++))
<span class="kw">import </span><span class="dt">Data.Array.Repa.IO.DevIL</span>
<span class="kw">import </span><span class="dt">Data.Array.Repa.Repr.ForeignPtr</span>

<span class="ot">main ::</span> <span class="dt">IO</span> () 
main <span class="fu">=</span> <span class="kw">do</span>
  [f] <span class="ot">&lt;-</span> getArgs
  (<span class="dt">RGB</span> v) <span class="ot">&lt;-</span> runIL <span class="fu">$</span> readImage f
  rotated <span class="ot">&lt;-</span> (computeP <span class="fu">$</span> rot180 v)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Array</span> <span class="dt">F</span> <span class="dt">DIM3</span> <span class="dt">Word8</span>)
  runIL <span class="fu">$</span> writeImage (<span class="st">&quot;flip-&quot;</span><span class="fu">++</span>f) (<span class="dt">RGB</span> rotated)

<span class="ot">rot180 ::</span> (<span class="dt">Source</span> r e) <span class="ot">=&gt;</span> <span class="dt">Array</span> r <span class="dt">DIM3</span> e <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">D</span> <span class="dt">DIM3</span> e
rot180 g <span class="fu">=</span> backpermute e flop g
  <span class="kw">where</span>
    e<span class="fu">@</span>(<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">:.</span> y <span class="fu">:.</span> _) <span class="fu">=</span> extent g
    flop (<span class="dt">Z</span> <span class="fu">:.</span> i         <span class="fu">:.</span> j         <span class="fu">:.</span> k) <span class="fu">=</span>
         (<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">-</span> i <span class="fu">-</span> <span class="dv">1</span> <span class="fu">:.</span> y <span class="fu">-</span> j <span class="fu">-</span> <span class="dv">1</span> <span class="fu">:.</span> k)</code></pre>
</section>
<section id="concurrency" class="slide level1">
<h1>Concurrency</h1>
</section>
<section id="concurrent-http" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Network.HTTP</span>

<span class="ot">getHTTP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
getHTTP url <span class="fu">=</span> simpleHTTP (getRequest url) <span class="fu">&gt;&gt;=</span> getResponseBody

<span class="ot">urls ::</span> [<span class="dt">String</span>]
urls <span class="fu">=</span> map (<span class="st">&quot;http://ifconfig.me/&quot;</span><span class="fu">++</span>) [<span class="st">&quot;ip&quot;</span>, <span class="st">&quot;host&quot;</span>]

<span class="ot">startRequest ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> ())
startRequest url <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> newEmptyMVar
  forkIO (getHTTP url <span class="fu">&gt;&gt;=</span> putStr <span class="fu">&gt;&gt;</span> putMVar v ())
  return v

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mvars <span class="ot">&lt;-</span> mapM startRequest urls
  mapM_ takeMVar mvars</code></pre>
</section>
<section id="why-not-haskell" class="slide level1">
<h1>Why not Haskell?</h1>
<ul>
<li>Lots of new terminology</li>
<li>Mutable state takes more effort</li>
<li>Laziness changes how you need to reason about code</li>
<li>Once you get used to it, these aren't problematic</li>
</ul>
</section>
<section id="terminology" class="slide level1">
<h1></h1>
<p><em>A monad is just a monoid in the category of endofunctors, what's the problem?</em></p>
<p>Terminology from category theory can be intimidating (at first)!</p>
<p><code>return</code> probably doesn't mean what you think it means.</p>
</section>
<section id="laziness-behavior-1" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum []     <span class="fu">=</span> <span class="dv">0</span>
sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs</code></pre>
</section>
<section id="laziness-behavior-2" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go acc (x<span class="fu">:</span>xs) <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go acc []     <span class="fu">=</span> acc</code></pre>
</section>
<section id="laziness-behavior-3" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go acc _
      <span class="fu">|</span> seq acc <span class="dt">False</span> <span class="fu">=</span> undefined
    go acc (x<span class="fu">:</span>xs)     <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go acc []         <span class="fu">=</span> acc</code></pre>
</section>
<section id="laziness-behavior-4" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>

sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go <span class="fu">!</span>acc (x<span class="fu">:</span>xs) <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go  acc []     <span class="fu">=</span> acc</code></pre>
</section>
<section id="notable-libraries" class="slide level1">
<h1>Notable Libraries</h1>
</section>
<section id="web-frameworks" class="slide level1">
<h1>Web Frameworks</h1>
<dl>
<dt><a href="http://snapframework.com/">Snap</a></dt>
<dd>HTTP + Templates. Extensible with &quot;Snaplets&quot;
</dd>
<dt><a href="http://www.yesodweb.com/">Yesod</a></dt>
<dd>Full stack, uses Template Haskell
</dd>
<dt><a href="http://happstack.com/">Happstack</a></dt>
<dd>Full stack, does not rely on Template Haskell (happstack-lite)
</dd>
<dt><a href="https://github.com/ku-fpg/scotty">scotty</a></dt>
<dd>Like Ruby Sinatra, great for simple REST apps
</dd>
</dl>
</section>
<section id="publishing-and-docs" class="slide level1">
<h1>Publishing and docs</h1>
<dl>
<dt><a href="http://www.haskell.org/haddock/">Haddock</a></dt>
<dd>Standard library documentation tool for Haskell projects
</dd>
<dt><a href="http://projects.haskell.org/diagrams/">diagrams</a></dt>
<dd>DSL for vector graphics
</dd>
<dt><a href="http://jaspervdj.be/hakyll/">hakyll</a></dt>
<dd>Static site generator
</dd>
<dt><a href="http://johnmacfarlane.net/pandoc/">Pandoc</a></dt>
<dd>Markup format swiss-army knife (Markdown, LaTeX, EPUB, …)
</dd>
</dl>
</section>
<section id="parser-combinators-1" class="slide level1">
<h1>Parser Combinators</h1>
<dl>
<dt><a href="http://hackage.haskell.org/package/parsec">Parsec</a></dt>
<dd>Industrial strength, monadic parser combinator library for Haskell
</dd>
<dt><a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a></dt>
<dd>Like Parsec, but makes a few trade-offs for performance
</dd>
</dl>
</section>
<section id="dev-tools" class="slide level1">
<h1>Dev Tools</h1>
<dl>
<dt><a href="http://community.haskell.org/~ndm/hlint/">HLint</a></dt>
<dd>Suggests improvements for your code
</dd>
<dt><a href="http://www.mew.org/~kazu/proj/ghc-mod/en/">ghc-mod</a>, <a href="https://github.com/bitc/hdevtools">hdevtools</a></dt>
<dd>Editor integration
</dd>
<dt><a href="http://www.haskell.org/hoogle/">Hoogle</a>, <a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html">Hayoo</a></dt>
<dd>Search for Haskell functions by name or <em>by type</em>!
</dd>
<dt><a href="http://hackage.haskell.org/package/djinn">Djinn</a></dt>
<dd>Automatically generate code given a type!
</dd>
<dt><a href="https://hackage.haskell.org/package/tidal">tidal</a></dt>
<dd>DSL for live coding music patterns (&quot;algorave&quot;)
</dd>
</dl>
</section>
<section id="parallel-distributed" class="slide level1">
<h1>Parallel / Distributed</h1>
<dl>
<dt><a href="http://repa.ouroborus.net/">repa</a></dt>
<dd>High performance, regular, multi-dimensional arrays (with multi-core!)
</dd>
<dt><a href="https://github.com/AccelerateHS/accelerate/">accelerate</a></dt>
<dd>Like repa, but can utilize CUDA to run on GPUs
</dd>
<dt><a href="http://haskell-distributed.github.io/">Cloud Haskell</a></dt>
<dd>Erlang-like concurrency and distribution for Haskell
</dd>
</dl>
</section>
<section id="testing-profiling" class="slide level1">
<h1>Testing &amp; Profiling</h1>
<dl>
<dt><a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a></dt>
<dd>Property based testing
</dd>
<dt><a href="http://hackage.haskell.org/package/HUnit">HUnit</a></dt>
<dd>Standard unit testing framework
</dd>
<dt><a href="http://www.haskell.org/haskellwiki/Haskell_program_coverage">hpc</a></dt>
<dd>Haskell Program Coverage
</dd>
<dt><a href="http://www.haskell.org/haskellwiki/ThreadScope">ThreadScope</a></dt>
<dd>Visualize multi-core utilization
</dd>
<dt><a href="https://github.com/bos/criterion">criterion</a></dt>
<dd>Gold standard for performance benchmarking
</dd>
<dt><a href="https://github.com/tibbe/ekg">EKG</a></dt>
<dd>Embeds a web-server for live monitoring of metrics
</dd>
</dl>
</section>
<section id="learn-more" class="slide level1">
<h1>Learn More</h1>
<dl>
<dt>Books</dt>
<dd><a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a>
</dd>
<dd><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a>
</dd>
<dd><a href="http://book.realworldhaskell.org/">Real World Haskell</a>
</dd>
<dt>Lectures</dt>
<dd><a href="http://www.scs.stanford.edu/11au-cs240h/">Functional Systems in Haskell</a> - CS240h Autumn 2011, Stanford
</dd>
<dd><a href="http://shuklan.com/haskell/index.html">Introduction to Haskell</a> - CS1501 Spring 2013, UVA
</dd>
<dd><a href="http://www.seas.upenn.edu/~cis194/">Introduction to Haskell</a> - CIS 194 Spring 2013, UPenn
</dd>
<dd><a href="http://courses.cms.caltech.edu/cs11/material/haskell/">Haskell Track</a> - CS 11 Fall 2011, Caltech
</dd>
<dt>Practice</dt>
<dd><a href="http://exercism.io/">exercism.io</a>, <a href="http://www.talentbuddy.co/">Talentbuddy</a>, <a href="https://www.hackerrank.com/">HackerRank</a>
</dd>
<dd><a href="http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems">H-99</a>, <a href="http://projecteuler.net/">Project Euler</a>
</dd>
</dl>
</section>
<section id="thanks" class="slide level1">
<h1>Thanks!</h1>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Slides</strong></p></td>
<td style="text-align: left;"><p><a href="http://bob.ippoli.to/haskell-for-erlangers-2014/">bob.ippoli.to/haskell-for-erlangers-2014</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Source</strong></p></td>
<td style="text-align: left;"><p><a href="https://github.com/etrepum/haskell-for-erlangers-2014">github.com/etrepum/haskell-for-erlangers-2014</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>Email</strong></p></td>
<td style="text-align: left;"><p>bob@redivi.com</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Twitter</strong></p></td>
<td style="text-align: left;"><p><a href="https://twitter.com/etrepum">@etrepum</a></p></td>
</tr>
</tbody>
</table>
<!--
Other interesting presentations:
http://shuklan.com/haskell/lec01.html
http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf

TODO
http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
http://www.haskell.org/tutorial/goodies.html

-->

</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,
        center: false,
        slideNumber: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-30504730-1', 'ippoli.to');
  ga('send', 'pageview');

</script>
  </body>
</html>
